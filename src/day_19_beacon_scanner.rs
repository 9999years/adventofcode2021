use std::collections::hash_map::DefaultHasher;
use std::collections::{BTreeMap, HashMap, HashSet, VecDeque};
use std::hash::{Hash, Hasher};
use std::ops::{Add, Mul, Neg, Sub};
use std::{fmt::Debug, str::FromStr};

use crate::*;

/// Minimum common beacons to consider two scanners overlapping.
const MIN_COMMON: usize = 12;
/// Number of nearest neighbors to consider for each scanner.
const NEIGHBORS: usize = 4;
/// Threshold used in beacon matching between scanners.
const SIMILARITY_THRESHOLD: f32 = 1.5;

/// All unique valid rotations. Generated by deduplicating:
/// ```plain
/// (0..4)
/// .cartesian_product(0..4)
/// .cartesian_product(0..4)
/// .map(|((x, y), z)| Rotation::from_axes(x, y, z))
/// ```
const ROTATIONS: [Rotation; 24] = [
    Rotation([[0, -1, 0], [0, 0, 1], [-1, 0, 0]]),
    Rotation([[0, 1, 0], [1, 0, 0], [0, 0, -1]]),
    Rotation([[0, -1, 0], [1, 0, 0], [0, 0, 1]]),
    Rotation([[-1, 0, 0], [0, 1, 0], [0, 0, -1]]),
    Rotation([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]),
    Rotation([[1, 0, 0], [0, 0, -1], [0, 1, 0]]),
    Rotation([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),
    Rotation([[0, -1, 0], [0, 0, -1], [1, 0, 0]]),
    Rotation([[0, 1, 0], [0, 0, 1], [1, 0, 0]]),
    Rotation([[0, 0, -1], [-1, 0, 0], [0, 1, 0]]),
    Rotation([[0, 0, -1], [0, -1, 0], [-1, 0, 0]]),
    Rotation([[-1, 0, 0], [0, 0, -1], [0, -1, 0]]),
    Rotation([[0, 0, 1], [-1, 0, 0], [0, -1, 0]]),
    Rotation([[0, 0, -1], [1, 0, 0], [0, -1, 0]]),
    Rotation([[1, 0, 0], [0, 0, 1], [0, -1, 0]]),
    Rotation([[0, -1, 0], [-1, 0, 0], [0, 0, -1]]),
    Rotation([[0, 0, 1], [0, -1, 0], [1, 0, 0]]),
    Rotation([[0, 1, 0], [-1, 0, 0], [0, 0, 1]]),
    Rotation([[0, 0, 1], [0, 1, 0], [-1, 0, 0]]),
    Rotation([[0, 0, 1], [1, 0, 0], [0, 1, 0]]),
    Rotation([[-1, 0, 0], [0, 0, 1], [0, 1, 0]]),
    Rotation([[1, 0, 0], [0, -1, 0], [0, 0, -1]]),
    Rotation([[0, 0, -1], [0, 1, 0], [1, 0, 0]]),
    Rotation([[0, 1, 0], [0, 0, -1], [-1, 0, 0]]),
];

/// A 3-dimensional point with integer coordinates.
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)]
pub struct Point(isize, isize, isize);

impl Debug for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("")
            .field(&self.0)
            .field(&self.1)
            .field(&self.2)
            .finish()
    }
}

impl FromStr for Point {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let nums: Vec<isize> = s
            .split(',')
            .map(|num| num.parse().map_err(|err| format!("{}: {:?}", err, num)))
            .collect::<Result<_, _>>()?;
        nums.try_conv::<[_; 3]>()
            .map(|[x, y, z]| Self(x, y, z))
            .map_err(|nums| format!("Expected 3 dimensions, found {} ({:?})", nums.len(), nums))
    }
}

macro_rules! _impl_point_arith {
    ($ty:ty) => {
        impl Add for $ty {
            type Output = Point;

            fn add(self, rhs: Self) -> Self::Output {
                Point(self.0 + rhs.0, self.1 + rhs.1, self.2 + rhs.2)
            }
        }

        impl Sub for $ty {
            type Output = Point;

            fn sub(self, rhs: Self) -> Self::Output {
                Point(self.0 - rhs.0, self.1 - rhs.1, self.2 - rhs.2)
            }
        }

        impl Neg for $ty {
            type Output = Point;

            fn neg(self) -> Self::Output {
                Point(-self.0, -self.1, -self.2)
            }
        }
    };
}

_impl_point_arith!(Point);
_impl_point_arith!(&Point);

impl Point {
    /// The square of the distance between this point and `other`.
    pub fn magnitude_sqr(&self) -> isize {
        self.0 * self.0 + self.1 * self.1 + self.2 * self.2
    }

    /// O(points.len() * log NEIGHBORS)
    ///
    /// # Panics
    /// If `points.len() < NEIGHBORS`
    pub fn nearest_points(&self, points: &[Point]) -> (Distances, Neighborhood) {
        // Find nearest points:
        let mut candidates = Vec::<(isize, Point)>::with_capacity(NEIGHBORS + 1);
        for point in points {
            let relative = point - self;
            let distance = relative.magnitude_sqr();
            match candidates.binary_search_by(|(probe, _)| probe.cmp(&distance)) {
                Ok(_index) => {
                    // Found the point; this means there's duplicates in `points`!
                }
                Err(index) => {
                    // `index` is where `point` _should_ be in `candidates`.
                    let insert = (distance, relative);
                    if candidates.len() < NEIGHBORS {
                        // We don't have a full set of candidates yet.
                        candidates.insert(index, insert);
                    } else if index < candidates.len() {
                        // Swap with an existing element:
                        candidates[index] = insert;
                    } else {
                        // Otherwise, it's not closer than the other elements.
                    }
                }
            }
        }

        let mut distances = Vec::with_capacity(NEIGHBORS);
        let mut points = Vec::with_capacity(NEIGHBORS);
        for (distance, point) in candidates {
            points.push(point);
            distances.push(distance);
        }

        (
            Distances(distances.try_conv::<[_; NEIGHBORS]>().unwrap()),
            Neighborhood {
                point: self.clone(),
                neighbors: points.try_conv::<[_; NEIGHBORS]>().unwrap(),
            },
        )
    }
}

/// 3D rotation matrix.
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct Rotation([[isize; 3]; 3]);

impl Rotation {
    /// Get a new rotation with the given number of 90-degree clockwise
    /// rotations around the x, y, and z axes.
    pub fn from_axes(x: u8, y: u8, z: u8) -> Self {
        fn cos90(angle: u8) -> isize {
            match angle % 4 {
                0 => 1,
                1 => 0,
                2 => -1,
                3 => 0,
                _ => unreachable!(),
            }
        }

        fn sin90(angle: u8) -> isize {
            match angle % 4 {
                0 => 0,
                1 => 1,
                2 => 0,
                3 => -1,
                _ => unreachable!(),
            }
        }

        // https://en.wikipedia.org/wiki/Rotation_matrix#General_rotations
        Self([
            [
                cos90(z) * cos90(y),
                cos90(z) * sin90(y) * sin90(x) - sin90(z) * cos90(x),
                cos90(z) * sin90(y) * cos90(x) + sin90(z) * sin90(x),
            ],
            [
                sin90(z) * cos90(y),
                sin90(z) * sin90(y) * sin90(x) + cos90(z) * cos90(x),
                sin90(z) * sin90(y) * cos90(x) - cos90(z) * sin90(x),
            ],
            [-sin90(y), cos90(y) * sin90(x), cos90(y) * cos90(x)],
        ])
    }

    /// Apply this rotation to a point.
    pub fn apply(&self, point: &Point) -> Point {
        let x = self.0[0];
        let y = self.0[1];
        let z = self.0[2];
        Point(
            x[0] * point.0 + x[1] * point.1 + x[2] * point.2,
            y[0] * point.0 + y[1] * point.1 + y[2] * point.2,
            z[0] * point.0 + z[1] * point.1 + z[2] * point.2,
        )
    }

    /// Get the transpose of this rotation matrix.
    pub fn transpose(&self) -> Self {
        Self([
            [self.0[0][0], self.0[1][0], self.0[2][0]],
            [self.0[0][1], self.0[1][1], self.0[2][1]],
            [self.0[0][2], self.0[1][2], self.0[2][2]],
        ])
    }
}

/// The identity matrix.
impl Default for Rotation {
    fn default() -> Self {
        Self([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
    }
}

/// This is array multiplication.
impl Add for Rotation {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        let sx = self.0[0];
        let sy = self.0[1];
        let sz = self.0[2];
        let rx = rhs.0[0];
        let ry = rhs.0[1];
        let rz = rhs.0[2];

        Rotation([
            [
                sx[0] * rx[0] + sx[1] * ry[0] + sx[2] * rz[0],
                sx[0] * rx[1] + sx[1] * ry[1] + sx[2] * rz[1],
                sx[0] * rx[2] + sx[1] * ry[2] + sx[2] * rz[2],
            ],
            [
                sy[0] * rx[0] + sy[1] * ry[0] + sy[2] * rz[0],
                sy[0] * rx[1] + sy[1] * ry[1] + sy[2] * rz[1],
                sy[0] * rx[2] + sy[1] * ry[2] + sy[2] * rz[2],
            ],
            [
                sz[0] * rx[0] + sz[1] * ry[0] + sz[2] * rz[0],
                sz[0] * rx[1] + sz[1] * ry[1] + sz[2] * rz[1],
                sz[0] * rx[2] + sz[1] * ry[2] + sz[2] * rz[2],
            ],
        ])
    }
}

/// Elementwise negation of the matrix.
impl Neg for Rotation {
    type Output = Self;

    fn neg(self) -> Self::Output {
        Self([
            [-self.0[0][0], -self.0[0][1], -self.0[0][2]],
            [-self.0[1][0], -self.0[1][1], -self.0[1][2]],
            [-self.0[2][0], -self.0[2][1], -self.0[2][2]],
        ])
    }
}

/// The special Euclidean group SE(3). (Rotations + translations.)
#[derive(Debug, Clone, Copy, Default)]
pub struct Alignment {
    rotation: Rotation,
    translation: Point,
}

impl Alignment {
    pub fn apply(&self, point: &Point) -> Point {
        self.rotation.apply(point) + self.translation
    }

    pub fn manhattan_distance(&self, other: &Alignment) -> usize {
        let ret = other.translation - self.translation;
        (ret.0.abs() + ret.1.abs() + ret.2.abs()) as usize
    }
}

/// Group operation on SE(3).
/// See page 8 of https://ethaneade.com/lie.pdf
impl Add for Alignment {
    type Output = Alignment;

    fn add(self, rhs: Self) -> Self::Output {
        Alignment {
            rotation: self.rotation + rhs.rotation,
            translation: self.rotation.apply(&rhs.translation) + self.translation,
        }
    }
}

/// Inverse operation on SE(3).
/// See page 8 of https://ethaneade.com/lie.pdf
impl Neg for Alignment {
    type Output = Self;

    fn neg(self) -> Self::Output {
        let rot_transpose = self.rotation.transpose();
        Alignment {
            rotation: rot_transpose,
            translation: -rot_transpose.apply(&self.translation),
        }
    }
}

/// A set of distances of near neighbors to a point.
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Distances([isize; NEIGHBORS]);

impl Distances {
    /// A similarity metric between distance lists.
    ///
    /// 1 point for each common distance, -0.25 points for each missed distance.
    pub fn similarity(&self, other: &Distances) -> f32 {
        let mut i = 0;
        let mut j = 0;
        let mut ret = 0.0;

        while i < self.0.len() && j < other.0.len() {
            let item_i = self.0[i];
            let item_j = other.0[j];
            if item_i == item_j {
                i += 1;
                j += 1;
                ret += 1.0;
            } else if item_i < item_j {
                i += 1;
                ret -= 0.25;
            } else {
                j += 1;
                ret -= 0.25;
            }
        }

        ret
    }
}

/// A point and its nearest neighbors.
#[derive(Debug, PartialEq, Eq)]
pub struct Neighborhood {
    point: Point,
    neighbors: [Point; NEIGHBORS],
}

/// Get it, a suburb of neighborhoods?
struct Suburb(BTreeMap<Distances, Neighborhood>);

impl From<&[Point]> for Suburb {
    fn from(points: &[Point]) -> Self {
        Self(
            points
                .iter()
                .map(|point| point.nearest_points(&points))
                .collect(),
        )
    }
}

impl Suburb {
    /// Determine similar points between two suburbs.
    pub fn similar<'s, 'o>(&'s self, other: &'o Suburb) -> Vec<(&'s Point, &'o Point)> {
        self.0
            .iter()
            .cartesian_product(other.0.iter())
            .filter_map(|((a_dist, a_neighborhood), (b_dist, b_neighborhood))| {
                if a_dist.similarity(b_dist) >= SIMILARITY_THRESHOLD {
                    Some((&a_neighborhood.point, &b_neighborhood.point))
                } else {
                    None
                }
            })
            .collect()
    }
}

/// A scanner and its associated beacons (points).
struct Scanner {
    /// Points, hashed by actual position.
    beacons: HashSet<Point>,
    /// Points, ordered by distance to nearest neighbors.
    neighborhoods: Suburb,
}

impl Scanner {
    pub fn new(beacons: &[Point]) -> Self {
        Scanner {
            neighborhoods: beacons.into(),
            beacons: beacons.iter().cloned().collect(),
        }
    }

    /// With common points `common`, align this scanner with another.
    pub fn align_with<'s, 'o>(
        &'s self,
        other: &'o Scanner,
        common: &'_ [(&'s Point, &'o Point)],
    ) -> Option<(Alignment, Vec<Point>)> {
        for rotation in ROTATIONS {
            // Check if all points align for this `rotation`.
            for (point_a, point_b) in common {
                // Assume `reference_point` determines alignment between the two scanners.
                // I _think_ this gets you the offset from `self` to `other`.
                let other_rotated = rotation.apply(point_b);
                let other_offset = *point_a - &other_rotated;
                let alignment = Alignment {
                    rotation,
                    translation: other_offset,
                };
                // Check that this orientation works with at least MIN_COMMON points.
                let aligned = other
                    .beacons
                    .iter()
                    .map(|point| alignment.apply(point))
                    .filter(|aligned_point| self.beacons.contains(aligned_point))
                    .collect::<Vec<_>>();

                // `>= MIN_COMMON` is what we call in the industry "business logic".
                if aligned.len() >= MIN_COMMON {
                    return Some((alignment, aligned));
                }
            }
        }
        None
    }
}

/// An adjacency matrix of connections between scanners.
pub struct AdjacencyMatrix(Vec<Vec<Option<(Alignment, Vec<Point>)>>>);

impl AdjacencyMatrix {
    pub fn connections(
        &self,
        index: usize,
    ) -> impl Iterator<Item = (usize, bool, &Alignment, &[Point])> {
        self.0[index]
            .iter()
            .enumerate()
            .filter_map(|(i, conn)| {
                conn.as_ref()
                    .map(|(alignment, common)| (i, false, alignment, common.as_slice()))
            })
            .chain(self.0.iter().enumerate().filter_map(move |(i, row)| {
                row[index]
                    .as_ref()
                    .map(|(alignment, common)| (i, true, alignment, common.as_slice()))
            }))
    }
}

/// A list of scanners.
pub struct Scanners(Vec<Scanner>);

impl Scanners {
    // Find connections (overlaps) between scanners.
    pub fn find_connections(&self) -> AdjacencyMatrix {
        // TODO: this doesn't find all connections!
        let mut ret = vec![vec![None; self.0.len()]; self.0.len()];
        // Iterate over the upper triangle of pairs (a, b) to avoid processing
        // (a, b) and (b, a).
        for (a, scanner_a) in self.0.iter().enumerate() {
            if a + 1 > self.0.len() {
                // No next element.
                break;
            }
            let b_start = a + 1;
            for (b, scanner_b) in self.0[b_start..].iter().enumerate() {
                let b = b + b_start;
                let common_beacons_guess =
                    scanner_a.neighborhoods.similar(&scanner_b.neighborhoods);
                if common_beacons_guess.len() > 1 {
                    if let Some((alignment, common_beacons)) =
                        scanner_a.align_with(scanner_b, &common_beacons_guess)
                    {
                        ret[a][b] = Some((alignment, common_beacons));
                    }
                }
            }
        }
        AdjacencyMatrix(ret)
    }

    /// Assemble the full beacon-map.
    /// Returns a map of scanner index to alignment (for distances between
    /// scanners) and the completed beacon-map of deduplicated points.
    pub fn assemble_map(&self) -> (HashMap<usize, Alignment>, HashSet<Point>) {
        let adjacencies = self.find_connections();

        // Fully-assembled beacon-map.
        let mut all_beacons =
            HashSet::with_capacity(self.0.iter().map(|scanner| scanner.beacons.len()).sum());
        let mut alignments = HashMap::with_capacity(self.0.len());

        let mut explored = HashSet::<usize>::with_capacity(self.0.len());
        explored.insert(0);
        let mut to_explore = VecDeque::with_capacity(self.0.len());
        to_explore.push_back((0, Alignment::default()));

        // Need to do a BFS search over scanners starting at 0 connecting to
        // adjacents and computing nested offsets/alignments.
        while let Some((index, alignment)) = to_explore.pop_front() {
            alignments.insert(index, alignment);
            all_beacons.extend(
                self.0[index]
                    .beacons
                    .iter()
                    .map(|beacon| alignment.apply(beacon)),
            );

            for (connected_index, reversed, connected_alignment, _common) in
                adjacencies.connections(index)
            {
                if !explored.contains(&connected_index) {
                    let new_alignment = if reversed {
                        alignment + -*connected_alignment
                    } else {
                        alignment + *connected_alignment
                    };
                    explored.insert(connected_index);
                    to_explore.push_back((connected_index, new_alignment));
                }
            }
        }

        if explored.len() != self.0.len() {
            panic!(
                "Explored {} scanners instead of {}. Missed scanners: {:?}",
                explored.len(),
                self.0.len(),
                (0..self.0.len())
                    .filter(|i| !explored.contains(i))
                    .collect::<Vec<_>>()
            );
        }

        (alignments, all_beacons)
    }
}

/// Parse puzzle input.
impl FromStr for Scanners {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut ret = Vec::new();
        let mut points = Vec::with_capacity(64);

        let mut new_scanner = true;

        for line in s.lines() {
            if new_scanner {
                if !line.starts_with("--- scanner ") || !line.ends_with(" ---") {
                    return Err(format!("Expected scanner header, found {:?}", line));
                }
                new_scanner = false;
            } else {
                if line.trim().is_empty() {
                    // Empty line between scanners.
                    new_scanner = true;
                    ret.push(Scanner::new(&points));
                    points.clear();
                } else {
                    // Collect another point.
                    points.push(line.parse()?);
                }
            }
        }

        if !new_scanner {
            ret.push(Scanner::new(&points));
        }

        Ok(Self(ret))
    }
}

type Input = Scanners;

pub fn part_1(input: Input) -> usize {
    input.assemble_map().1.len()
}

pub fn part_2(input: Input) -> usize {
    let alignments = input.assemble_map().0;
    let mut longest_distance = 0;
    for a in alignments.values() {
        for b in alignments.values() {
            longest_distance = longest_distance.max(a.manhattan_distance(b));
        }
    }
    longest_distance
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample() -> Input {
        input!("day_19_beacon_scanner_sample").parse().unwrap()
    }

    fn input() -> Input {
        input!("day_19_beacon_scanner").parse().unwrap()
    }

    #[test]
    fn test_part_1_sample() {
        assert_eq!(part_1(sample()), 79);
    }

    #[test]
    fn test_part_1() {
        assert_eq!(part_1(input()), 491);
    }

    #[test]
    fn test_part_2_sample() {
        assert_eq!(part_2(sample()), 3621);
    }

    #[test]
    fn test_part_2() {
        assert_eq!(part_2(input()), 13374);
    }
}
